package kevin.module.modules.exploit

import io.netty.buffer.Unpooled
import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.UpdateEvent
import kevin.event.WorldEvent
import kevin.module.*
import kevin.utils.ChatUtils
import kevin.utils.PacketUtils
import kevin.utils.RandomUtils
import kevin.utils.timers.MSTimer
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.SPacketPlayerPosLook
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

object Disabler : Module("Disabler","Disable some anti-cheat check.",category = ModuleCategory.EXPLOIT) {
    val modeValue = ListValue("Mode",arrayOf("MineplexCombat","OldHypixel","VerusCombat","VerusMove","VerusRidingSpoof","Flying","Spectate","SpectateSpoof","SpectateSpoof2","VulcanGeyser","C13+InfiniteC0C","NoGroundTouch","NoGroundTouch2","MemetrixScaffold","FakeLag","RidingSpoof","Kauri","Basic"),"MinePlexCombat")
    private val debug = BooleanValue("Debug", false)
    private val memeAACValue = BooleanValue("MemetrixWithAAC5", false)
    private val fakeLagPosValue = BooleanValue("FakeLagPosition", true)
    private val fakeLagBlockValue = BooleanValue("FakeLagBlock", true)
    private val fakeLagAttackValue = BooleanValue("FakeLagAttack", true)
    private val fakeLagSpoofValue = BooleanValue("FakeLagC03Spoof", false)
    private val lagDelayValue = IntegerValue("LagDelay",0,0,2000)
    private val lagDurationValue = IntegerValue("LagDuration",200,100,1000)

    private var verus2Stat=false
    private var packetBuffer=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var currentTrans=0
    private var memeTick=0
    private var isSent=false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()

    override fun onEnable() {
        reset()
    }

    override fun onDisable() {
        when(modeValue.get().lowercase()){
            "memetrixscaffold" -> {
                for(packet in packetBuffer){
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "fakelag" -> {
                for(packet in packetBuffer){
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent){
        reset()
    }

    private fun reset(){
        memeTick=0
        currentTrans=0
        verus2Stat=false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent){
        when(modeValue.get().lowercase()){
            "verusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.player.ticksExisted % 180 == 0) {
                    // grab packets untill the queue size is 22 or less.
                    while (packetBuffer.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        PacketUtils.sendPacketNoEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            "memetrixscaffold" -> {
                memeTick++
                val cTick=if(memeAACValue.get()){
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*10).roundToInt()
                }else{
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*7.6).roundToInt()
                }
                if(memeTick>=cTick){
                    memeTick=0
                    for(packet in packetBuffer){
                        PacketUtils.sendPacketNoEvent(packet)
                    }

                    debugMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }

            "fakelag" -> {
                if(!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                //Send
                if(fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for(packet in packetBuffer){
                        PacketUtils.sendPacketNoEvent(packet)
                    }
                    debugMessage("Release buf(size=${packetBuffer.size})")
                    isSent=true
                    packetBuffer.clear()
                }
            }
        }
    }


    @EventTarget
    fun onPacket(event: PacketEvent){
        val packet=event.packet

        when(modeValue.get().lowercase()){
            "mineplexcombat" -> {
                if (packet is CPacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(CPacketKeepAlive(packet.key- RandomUtils.nextInt(1000, 2147483647)))
                    debugMessage("Packet C00")
                }
            }

            "oldhypixel" -> {
                if (packet is CPacketConfirmTransaction) {
                    event.cancelEvent()
                    debugMessage("Packet C0F")
                }
            }

            "verusridingspoof" -> {
                if (packet is CPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if(packet is CPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
                if (packet is CPacketPlayer) mc.connection!!.sendPacket(CPacketInput(mc.player.moveStrafing, mc.player.moveForward, mc.player.movementInput.jump, mc.player.movementInput.sneak))
            }

            "veruscombat" -> {
                if (packet is CPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if(packet is CPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
            }

            "verusmove" -> {
                if (mc.player != null && mc.player.ticksExisted == 0) packetBuffer.clear()
                if (packet is CPacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.player.posY / 0.015625).roundToInt() * 0.015625
                    mc.player.setPosition(mc.player.posX, yPos, mc.player.posZ)
                    if (mc.player.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        PacketUtils.sendPacketNoEvent(
                            CPacketPlayer.Position(
                                mc.player.posX,
                                mc.player.posY,
                                mc.player.posZ,
                                true
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            CPacketPlayer.Position(
                                mc.player.posX,
                                mc.player.posY - 11.725,
                                mc.player.posZ,
                                false
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            CPacketPlayer.Position(
                                mc.player.posX,
                                mc.player.posY,
                                mc.player.posZ,
                                true
                            )
                        )
                    }
                } else if (packet is SPacketPlayerPosLook) {
                    val x = packet.x - mc.player.posX
                    val y = packet.y - mc.player.posY
                    val z = packet.z - mc.player.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        PacketUtils.sendPacketNoEvent(
                            CPacketPlayer.PositionRotation(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )
                    }
                } else if (packet is CPacketConfirmTransaction) {
                    for (i in 0..3) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                    }
                    event.cancelEvent()
                }
            }

            "vulcangeyser" -> {
                if (packet is CPacketPlayer && mc.player.ticksExisted % 15 == 0) {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.player.gameProfile.getName())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.connection!!.sendPacket(CPacketCustomPayload("vulcan:geyser", buf))
                }
            }

            "kauri" -> {
                if (packet is CPacketConfirmTransaction)
                    event.cancelEvent()
            }

            "ridingspoof" -> {
                if (packet is CPacketPlayer)
                    mc.connection!!.sendPacket(CPacketInput(mc.player.moveStrafing, mc.player.moveForward, mc.player.movementInput.jump, mc.player.movementInput.sneak))
            }

            "basic" -> {
                if (packet is CPacketConfirmTransaction || packet is CPacketKeepAlive)
                    event.cancelEvent()
            }

            "nogroundtouch2" -> {
                if (packet is CPacketPlayer)
                    packet.y += 0.125
            }

            "spectate" -> {
                if (packet is CPacketPlayer)
                    mc.connection!!.sendPacket(CPacketSpectate(mc.player.uniqueID))
            }

            "spectatespoof" -> {
                if (packet is CPacketPlayer) {
                    packet.onGround = false

                    mc.connection!!.sendPacket(CPacketSpectate(mc.player.uniqueID))
                    mc.connection!!.sendPacket(CPacketPlayerAbilities(mc.player.capabilities))
                }
                if (packet is CPacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }

            "spectatespoof2" -> {
                if (packet is CPacketPlayer)
                    mc.connection!!.sendPacket(CPacketSpectate(mc.player.uniqueID))
                if (packet is CPacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }


            "flying" -> {
                if (packet is CPacketPlayer) {
                    val capabilities= PlayerCapabilities() // flags=2
                    capabilities.disableDamage=false
                    capabilities.isFlying=true
                    capabilities.allowFlying=false
                    capabilities.isCreativeMode=false
                    mc.connection!!.sendPacket(CPacketPlayerAbilities(capabilities))
                    debugMessage("Packet C13")
                }
            }

            "memetrixscaffold" -> {
                if(packet is CPacketPlayer&&!(packet is CPacketPlayer.Position ||packet is CPacketPlayer.Rotation ||packet is CPacketPlayer.PositionRotation)){
                    event.cancelEvent()
                }
                if(packet is CPacketUseEntity||packet is CPacketPlayer.Position ||packet is CPacketPlayer.Rotation
                    ||packet is CPacketPlayer.PositionRotation ||packet is CPacketPlayerDigging||packet is CPacketPlayerTryUseItemOnBlock
                    ||packet is CPacketAnimation||packet is CPacketEntityAction){
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "fakelag" -> {
                if(fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if(isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(CPacketPlayer(true))
                        if(lagDurationValue.get()>=300) PacketUtils.sendPacketNoEvent(CPacketPlayer(true))
                        isSent = false
                    }
                    if(packet is CPacketKeepAlive||packet is CPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagAttackValue.get()&&(packet is CPacketUseEntity||packet is CPacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if(packet is CPacketAnimation) return
                    }
                    if(fakeLagBlockValue.get()&&(packet is CPacketPlayerDigging||packet is CPacketPlayerTryUseItemOnBlock||packet is CPacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagPosValue.get()&&(packet is CPacketPlayer||packet is CPacketPlayer.Position ||packet is CPacketPlayer.Rotation ||packet is CPacketPlayer.PositionRotation ||packet is CPacketEntityAction)){
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }

            "nogroundtouch" -> {
                PacketUtils.sendPacketNoEvent(CPacketPlayer.Position(mc.player.posX,
                    mc.player.posY + .125, mc.player.posZ, true))
            }

            "c13+infinitec0c" -> {
                PacketUtils.sendPacketNoEvent(CPacketPlayerAbilities(mc.player.capabilities))
                PacketUtils.sendPacketNoEvent(CPacketInput(Float.MAX_VALUE, Float.MAX_VALUE, false, false))
            }
        }
    }

    private fun debugMessage(str: String){
        if(debug.get())
            ChatUtils.messageWithPrefix(" [Disabler] $str")
    }

    override val tag: String
        get() = modeValue.get()
}