package kevin.module.modules.exploit

import kevin.event.*
import kevin.module.ListValue
import kevin.module.Module
import kevin.module.ModuleCategory
import kevin.utils.BlockUtils
import kevin.utils.MovementUtils
import kevin.utils.timers.TickTimer
import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.CPacketPlayer
import net.minecraft.util.math.AxisAlignedBB
import net.minecraft.util.math.BlockPos
import java.util.*
import kotlin.math.cos
import kotlin.math.sin

class Phase : Module("Phase", "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT) {

    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"), "Vanilla")

    private val tickTimer = TickTimer()

    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()

    @EventTarget
    fun onUpdate(event: UpdateEvent) {

        //if (event.eventState == UpdateState.OnUpdate) return

        val isInsideBlock: Boolean =
            BlockUtils.collideBlockIntersects(mc.player.entityBoundingBox) { block ->
                (block)!is BlockAir
            }
        if (isInsideBlock && !modeValue.get().equals("Mineplex",true)) {
            mc.player.noClip = true
            mc.player.motionY = 0.0
            mc.player.onGround = false
        }
        whenMode(isInsideBlock)
        tickTimer.update()
    }

    private fun whenMode(isInsideBlock: Boolean) {
        val netHandlerPlayClient = mc.connection!!
        when (modeValue.get().lowercase()) {
            "vanilla" -> {
                if (!mc.player.onGround || !tickTimer.hasTimePassed(2) || !mc.player
                        .isCollidedHorizontally || !(!isInsideBlock || mc.player.isSneaking)
                ) return
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(0.5, .0, 0.5, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.2, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(0.5, .0, 0.5, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX + 0.5, mc.player.posY, mc.player.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.player.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.player.setPosition(
                    mc.player.posX + x,
                    mc.player.posY,
                    mc.player.posZ + z
                )
                tickTimer.reset()
            }
            "skip" -> {
                if (!mc.player.onGround || !tickTimer.hasTimePassed(2) || !mc.player
                        .isCollidedHorizontally || !(!isInsideBlock || mc.player.isSneaking)
                ) return
                val direction: Double = MovementUtils.direction
                val posX = -sin(direction) * 0.3
                val posZ = cos(direction) * 0.3
                var i = 0
                while (i < 3) {
                    mc.connection!!.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY + 0.06, mc.player.posZ, true))
                    mc.connection!!.sendPacket(CPacketPlayer.Position(mc.player.posX + posX * i, mc.player.posY, mc.player.posZ + posZ * i, true))
                    ++i
                }
                mc.player.entityBoundingBox = mc.player.entityBoundingBox.offset(posX, .0, posZ)
                mc.player.setPositionAndUpdate(mc.player.posX + posX, mc.player.posY, mc.player.posZ + posZ)
                tickTimer.reset()
            }
            "spartan" -> {
                if (!mc.player.onGround || !tickTimer.hasTimePassed(2) || !mc.player
                        .isCollidedHorizontally || !(!isInsideBlock || mc.player.isSneaking)
                ) return
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(0.5, .0, 0.5, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX, mc.player.posY - 0.2, mc.player.posZ, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(0.5, .0, 0.5, true))
                netHandlerPlayClient.sendPacket(CPacketPlayer.Position(mc.player.posX + 0.5, mc.player.posY, mc.player.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.player.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.player.setPosition(mc.player.posX + x, mc.player.posY, mc.player.posZ + z)
                tickTimer.reset()
            }
            "clip" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.player
                        .isCollidedHorizontally || !(!isInsideBlock || mc.player.isSneaking)
                ) return
                val yaw = Math.toRadians(mc.player.rotationYaw.toDouble())
                val oldX: Double = mc.player.posX
                val oldZ: Double = mc.player.posZ
                var i = 1
                while (i <= 10) {
                    val x = -sin(yaw) * i
                    val z = cos(yaw) * i
                    if ((BlockUtils.getBlock(BlockPos(oldX + x, mc.player.posY, oldZ + z))) is BlockAir
                        && (BlockUtils.getBlock(BlockPos(oldX + x, mc.player.posY + 1, oldZ + z)))is BlockAir
                    ) {
                        mc.player.setPosition(oldX + x, mc.player.posY, oldZ + z)
                        break
                    }
                    i++
                }
                tickTimer.reset()
            }
            "aac3.5.0" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.player
                        .isCollidedHorizontally || !(!isInsideBlock || mc.player.isSneaking)
                ) return
                val yaw = Math.toRadians(mc.player.rotationYaw.toDouble())
                val oldX: Double = mc.player.posX
                val oldZ: Double = mc.player.posZ
                val x = -sin(yaw)
                val z = cos(yaw)
                mc.player.setPosition(oldX + x, mc.player.posY, oldZ + z)
                tickTimer.reset()
            }
        }
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mc.player != null && BlockUtils.collideBlockIntersects(
                mc.player.entityBoundingBox
            ) { block ->
                (block)!is BlockAir
            } && event.boundingBox != null && event.boundingBox!!.maxY > mc.player
                .entityBoundingBox.minY && !modeValue.get().equals("Mineplex",true)
        ) {
            val axisAlignedBB = event.boundingBox ?: return
            event.boundingBox = (
                AxisAlignedBB(
                    axisAlignedBB.maxX,
                    mc.player.entityBoundingBox.minY,
                    axisAlignedBB.maxZ,
                    axisAlignedBB.minX,
                    axisAlignedBB.minY,
                    axisAlignedBB.minZ
                )
            )
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if ((packet)is CPacketPlayer) {
            if (modeValue.get().equals("AAC3.5.0",true)) {
                val yaw = MovementUtils.direction
                packet.x = (packet.x - sin(yaw) * 0.00000001)
                packet.z = (packet.z + cos(yaw) * 0.00000001)
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.get().equals("mineplex",true)) {
            if (mc.player.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction: Double = MovementUtils.direction
                mc.player.setPosition(mc.player.posX + -sin(direction) * offset, mc.player.posY, mc.player.posZ + cos(direction) * offset)
            }
        }
    }

    @EventTarget fun onPushOut(event: PushOutEvent) = event.cancelEvent()

    override val tag: String
        get() = modeValue.get()
}