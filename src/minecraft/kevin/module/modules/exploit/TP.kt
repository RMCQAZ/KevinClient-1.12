package kevin.module.modules.exploit

import kevin.KevinClient
import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.UpdateEvent
import kevin.module.*
import kevin.module.modules.misc.Teams
import kevin.utils.BlockUtils
import kevin.utils.ChatUtils
import kevin.utils.MovementUtils
import kevin.utils.PathUtils
import net.minecraft.client.entity.EntityOtherPlayerMP
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.*
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Vec3d
import java.lang.Thread.sleep

class TP : Module("TP","Allows you to teleport around.",category = ModuleCategory.EXPLOIT) {
    val mode = ListValue("Mode", arrayOf("Flag","AAC"),"Flag")
    private val keepTick = IntegerValue("FlagKeepTick",40,10,60)
    private val autoBedFind = BooleanValue("AutoBedFind",false)
    private val bedFindRange = IntegerValue("BedFindRange",6,2,6)

    private val aacFlySpeedValue = FloatValue("Speed", 0.8f, 0.1f, 2f)
    private val aacPathFindMode = ListValue("AACPathFindMode", arrayOf("Direct","FindPath"),"Direct")
    private var fakePlayer: EntityOtherPlayerMP? = null
    private var flagTPState = 0
    private var playerPos = Vec3d(.0,.0,.0)
    override val tag: String
        get() = mode.get()
    override fun onEnable() {
        when(mode.get()) {
            "Flag" -> {
                flagTPState = if (!mc.playerController.isSpectator){
                    ChatUtils.messageWithPrefix("§7[§cTP§7] §cJump In To Void!")
                    0
                }else 1
            }
            "AAC" -> {
                val thePlayer = mc.player ?: return
                playerPos = Vec3d(mc.player.posX, mc.player.posY, mc.player.posZ)
                val playerMP = EntityOtherPlayerMP(mc.world!!, thePlayer.gameProfile)
                playerMP.rotationYawHead = thePlayer.rotationYawHead;
                playerMP.renderYawOffset = thePlayer.renderYawOffset;
                playerMP.rotationYawHead = thePlayer.rotationYawHead
                playerMP.copyLocationAndAnglesFrom(thePlayer)
                mc.world!!.addEntityToWorld(-1000, playerMP)
                //thePlayer.noClip = true
                fakePlayer = playerMP
            }
        }
    }
    override fun onDisable() {
        flagTPState = 0
        when(mode.get()) {
            "AAC" -> {
                val thePlayer = mc.player
                if (thePlayer == null || fakePlayer == null)
                    return
                //thePlayer.setPositionAndRotation(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord, thePlayer.rotationYaw, thePlayer.rotationPitch)
                mc.world!!.removeEntityFromWorld(fakePlayer!!.entityId)
                fakePlayer = null
                thePlayer.motionX = 0.0
                thePlayer.motionY = 0.0
                thePlayer.motionZ = 0.0

                //Do teleport
                val packetY = arrayOf(1.1,1.1,1.2,1.2,.8,.8,.4,.0,.0,1.1,1.1)
                repeat(11){
                    mc.connection!!.sendPacket(CPacketPlayer.Position(playerPos.x,playerPos.y+packetY[it],playerPos.z,true))
                }
                when(aacPathFindMode.get()){
                    "Direct" -> {
                        val packets = (mc.player.getDistance(playerPos.x,playerPos.y,playerPos.z).toInt() / 10) + 1
                        val xV = ((thePlayer.posX - playerPos.x)) / packets.toDouble()
                        val yV = ((thePlayer.posY - playerPos.y)) / packets.toDouble()
                        val zV = ((thePlayer.posZ - playerPos.z)) / packets.toDouble()
                        repeat(packets){
                            mc.connection!!.sendPacket(CPacketPlayer.Position(playerPos.x+xV*(it+1),playerPos.y+yV*(it+1),playerPos.z+zV*(it+1),true))
                        }
                    }
                    "FindPath" -> {
                        val path = PathUtils.findBlinkPath2(playerPos.x,playerPos.y,playerPos.z,thePlayer.posX,thePlayer.posY,thePlayer.posZ,thePlayer.getDistance(playerPos.x,playerPos.y,playerPos.z) % 10.0)
                        path.forEach {
                            mc.connection!!.sendPacket(CPacketPlayer.Position(it.x,it.y,it.z,true))
                        }
                    }
                }
                mc.connection!!.sendPacket(CPacketPlayer.Position(thePlayer.posX,thePlayer.posY-1,thePlayer.posZ,true))
                mc.connection!!.sendPacket(CPacketPlayer.Position(playerPos.x,playerPos.y,playerPos.z,true))
                Thread({
                    sleep(50L)
                    repeat(2) {
                        mc.connection!!.sendPacket(
                            CPacketPlayer.Position(
                                thePlayer.posX,
                                thePlayer.posY,
                                thePlayer.posZ,
                                true
                            )
                        )
                    }
                    sleep(50L)
                    mc.connection!!.sendPacket(
                        CPacketPlayer.Position(
                            thePlayer.posX + .09,
                            thePlayer.posY,
                            thePlayer.posZ,
                            true
                        )
                    )
                },"Teleport-SendPacket").start()
            }
        }
    }
    @EventTarget fun onUpdate(event: UpdateEvent){
        when(mode.get()){
            "Flag" -> {
                if (flagTPState >= 2){
                    mc.player.setPosition(mc.player.posX,mc.player.posY+9.25,mc.player.posZ)
                    mc.player.motionY=1.0
                    if (flagTPState > keepTick.get()+2) this.toggle()
                    flagTPState += 1
                }
                if (flagTPState == 1 && !mc.playerController.isSpectator) flagTPState = 2
                if (flagTPState == 0 && mc.playerController.isSpectator) flagTPState = 1
                if (autoBedFind.get() && mc.playerController.isSpectator) {
                    val teams = KevinClient.moduleManager.getModule("Teams") as Teams
                    val yRange = bedFindRange.get() downTo -bedFindRange.get()+1
                    val xzRange = -bedFindRange.get()..bedFindRange.get()
                    var bedPos: BlockPos? = null
                     l@ for (x in xzRange) {
                         for (z in xzRange) {
                             for (y in yRange){
                                 val pos = BlockPos(mc.player.posX.toInt()+x, mc.player.posY.toInt()+y, mc.player.posZ.toInt()+z)
                                 if (BlockUtils.getBlock(pos) == Blocks.BED&&(!teams.state||!teams.bedCheckValue.get()||pos !in teams.teamBed)) {
                                     bedPos = pos
                                     break@l
                                 }
                             }
                         }
                     }
                    if (bedPos!=null){
                        mc.player.setPositionAndUpdate(bedPos.x.toDouble()+.5,bedPos.y-1.toDouble(),bedPos.z.toDouble()+.5)
                    }
                }
            }
            "AAC" -> {
                val thePlayer = mc.player!!
                //thePlayer.noClip = true
                thePlayer.fallDistance = 0.0f
                val value = aacFlySpeedValue.get()
                thePlayer.motionY = 0.0
                thePlayer.motionX = 0.0
                thePlayer.motionZ = 0.0
                if (mc.gameSettings.keyBindJump.isKeyDown) thePlayer.motionY += value
                if (mc.gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY -= value
                MovementUtils.strafe(value)
            }
        }
    }
    @EventTarget fun onPacket(event: PacketEvent) {
        when(mode.get()){
            "AAC" -> {
                val packet = event.packet
                if (packet is CPacketPlayer || packet is CPacketEntityAction || packet is CPacketPlayerDigging || packet is CPacketAnimation) event.cancelEvent()
            }
        }
    }
}